cat("\nCXX14FLAGS += -mtune=native -fPIC -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2",
"CXX14=g++", # or clang++ but you may need a version postfix
file = M, sep = "\n", append = FALSE)
}else{
print(paste("Unknown OS :", R.version$os))
}
library(rstan)
schools =
data.frame(y = c(28., 8., -3., 7., -1., 1., 18., 12.),
s =c(15., 10., 16., 11., 9., 11., 10., 18.),
index=c("A","B","C","D","E","F","G", "H") )
eightschools_indep = "
data {
int<lower=0> J;         // number of schools
real y[J];              // estimated treatment effects
real<lower=0> sigma[J]; // standard error of effect estimates
}
parameters {
vector[J] theta;          // unscaled deviation from mu by school
}
model {
target += normal_lpdf(y | theta, sigma); // log-likelihood
}
"
data = list(J = dim(schools)[1], y=schools$y, sigma = schools$s)
fit.indep =
stan(model_code=eightschools_indep, data=data,
seed=1234567, chains=1, iter=2000, thin=10, algorithm="NUTS")
View(data)
View(fit.indep)
install.packages(modeest)
install.packages("modeest")
library(modeest)
install.views(“Econometrics”)
install.packages("ctv")
library(ctv)
install.views(Econometrics)
install.views("Econometrics")
mfv(c(1,2,1,2,3,3,3,4,5,4,5))
mfv(c(1,26,6,6,6,6,3,3,4,5,4,5))
mfv(c(1,26,6,6,3,3,4,5,4,5))
3+5
library(knitr)
include_graphics("./figure/fig9.png")
library(knitr)
library(knitr)
is.numeric(10)
is.numeric('3')
is.numeric("3")
is.character(5)
is.character('5')
is.character("5")
scan("z1.txt")
x <- 1:3
print(x^2)
print("abc")
cat("abc\n")
cat(x, "abc", "de\n")
cat(x, "abc", "de\n", sep = "")
print("abc")
cat("abc\n")
cat(x, "abc", "de\n")
cat(x, "abc", "de\n", sep = "")
print("abc")
cat("abc\n")
cat(x, "abc", "de\n")
cat(x, "abc", "de\n", sep = "")
library(knitr)
include_graphics("./figure/fig4.png")
id = c(1, 2, 3)
name = c('Mr. Foo', 'Ms. Bar', 'Mr. Baz')
score = c(95, 97, 92)
a = data.frame(id, name, score)
write.csv(a, file = 'a.csv')
write.csv(a, file = 'a2.csv', row.names = FALSE)
addr <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv"
w = read.csv(addr, header = TRUE, sep = ";")
w[1:6, 1:3]
e = rnorm(100)
n = length(e)
s = rep(0, n)
for (i  in  1:n) s[i] = sum(e[1:i])
t = 1:n
plot(t, s)
b = c(1, 5, 8, 0, -1, 2)
counter = 0
isPositive = TRUE
while (isPositive) {
counter = counter + 1
isPositive = (b[counter] >= 0)
}
cat("A negative number is detected at the",
counter, "th place.\n")
b = c(1, 5, -8, 0, -1, 2)
counter = 0
isPositive = TRUE
while (isPositive) {
counter = counter + 1
isPositive = (b[counter] >= 0)
}
cat("A negative number is detected at the",
counter, "th place.\n")
(x <- sample(1:5, 5))
counter = 0
for (val in x) {
counter = counter + 1
if (val == 4){
cat("x is 4 at the", counter, "th place.\n")
break
}
}
if (val == 2){
cat("x is 4 at the", counter, "th place.\n")
break
}
(x <- sample(1:5, 5))
counter = 0
for (val in x) {
counter = counter + 1
if (val == 2){
cat("x is 4 at the", counter, "th place.\n")
break
}
}
cat("x is 2 at the", counter, "th place.\n")
(x <- sample(1:5, 5))
counter = 0
for (val in x) {
counter = counter + 1
if (val == 2){
cat("x is 2 at the", counter, "th place.\n")
break
}
}
(x <- sample(1:5, 5))
counter = 0
cat("x is less than 3 at the", counter, "th place.\n")
(x <- sample(1:5, 5))
counter = 0
for (val in x) {
counter = counter + 1
if (val <= 3){
cat("x is less than 3 at the", counter, "th place.\n")
next
}
}
x
x = 3
if (x > 1) {
y = 1
} else {
y = -1
}
y
myvector = c(1, 1, 1, 2, 2, 2, 2)
mean(myvector)
myfunction <- function(x) {  20 + x * x }
myfunction(10)
myfunction(25)
fish(myvector)
x1 <- c(1, 2, 1, 2, 2, 3, 3, 4, 5, 4, 5)
(count_x1 <- tabulate(x1))
which.max(count_x1)
#최빈값 함수
MyMode <- function(xval){
count_xval <- tabulate(xval)
res <- which.max(count_xval)
return(res)
}
MyMode(x1) # x1 <- c(1, 2, 1, 2, 2, 3, 3, 4, 5, 4, 5)
MyMode(x2) # x2 <- c(3, 4, 7, 2, 3, 3, 7, 3, 2, 6, 6)
MyMode(x2) # x2 <- c(3, 4, 7, 2, 3, 3, 7, 3, 2, 6, 6)
#최빈값구하기
x1 <- c(1, 2, 1, 2, 2, 3, 3, 4, 5, 4, 5)
x2 <- c(3, 4, 7, 2, 3, 3, 7, 3, 2, 6, 6)
MyMode(x1) # x1 <- c(1, 2, 1, 2, 2, 3, 3, 4, 5, 4, 5)
MyMode(x2) # x2 <- c(3, 4, 7, 2, 3, 3, 7, 3, 2, 6, 6)
mdata = c(1, 2, 1, 3, 4, 9, 5)
which.max(mdata)
# vectorized
z2 <- c()
# looped
z1 <- c()
system.time(for (i in 1:1000000) {z1[i] <- x[i] + y[i]})
x <- y <- runif(1000000)
# looped
z1 <- c()
system.time(for (i in 1:1000000) {z1[i] <- x[i] + y[i]})
# vectorized
z2 <- c()
system.time(z2 <- x+y)
# looped
oddcount1 <- function(x) {
nodd <- 0
for (i in seq_along(x)) {
if (x[i] %% 2 == 1)
nodd <- nodd + 1
}
return(nodd)
}
View(oddcount1)
# vectorized
oddcount2 <- function(x) { return(sum(x %% 2 == 1)) }
system.time(oddcount1(xseq))
xseq <- sample(1:1000000, 100000, replace = T)
system.time(oddcount1(xseq))
system.time(oddcount2(xseq))
library(foreach)
library(doParallel)
library(e1071)   # SVM
library(Epi)     # ROC, AUC
data(iris)
# extract a subset (two features and two labels)
iris_ext <- subset(iris, select = c("Sepal.Length", "Sepal.Width", "Species"), Species %in% c("setosa","virginica"))
# extract a subset (two features and two labels)
iris_ext <- subset(iris, select = c("Sepal.Length", "Sepal.Width", "Species"), Species %in% c("setosa","virginica"))
# linear SVM model
SVM_model_linear = svm(Species ~ ., data=iris_ext, type='C-classification', kernel="linear", scale=FALSE, cost = 10)
SVM_model_linear
plot(x = iris_ext$Sepal.Length,  y = iris_ext$Sepal.Width,col = adjustcolor(as.numeric(iris_ext$Species), alpha = 0.6),pch = 19,  cex = 1.25,  xlab = "Sepal Length",  ylab = "Sepal Width",  main = "SVM Classification: Setosa vs Virginica",  axes = TRUE)
axis(1); axis(2); box();
legend('topright', c("setosa", "virginica"), col = c(1, 3), pch = c(19, 19))
# extract coefficients
cf <- coef(SVM_model_linear)
# plot decision boundary and margins
abline(-cf[1] / cf[3], -cf[2] / cf[3], col = "blue")          # decision boundary
abline(-(cf[1] + 1) / cf[3], -cf[2] / cf[3], col = "blue", lty = 2) # positive margin
abline(-(cf[1] - 1) / cf[3], -cf[2] / cf[3], col = "blue", lty = 2) # negative margin
# mark support vectors
points(SVM_model_linear$SV, col = 'blue', cex = 2)
install.packages("png")  # PNG 파일 읽기
install.packages("grid") # 이미지 시각화
install.packages("grid")
install.packages("grid")
install.packages("grid")
install.packages("grid")
install.packages("grid")
install.packages("grid")
library(png)
library(grid)
yolo_tiny_voc <- image_darknet_model(type = 'detect',
model = "tiny-yolo-voc.cfg",
weights = system.file(package="image.darknet", "models", "tiny-yolo-voc.weights"),
labels = system.file(package="image.darknet", "include", "darknet", "data", "voc.names"))
x <- image_darknet_detect(file = "./OD_test.jpg",
object = yolo_tiny_voc,
threshold = 0.19)
install.packages("dplyr")
install.packages("sf")
install.packages("tmap")
install.packages("ggmap")
install.packages("ggplot2")
install.packages("units")
library(dplyr) #데이터연산
library(sf) #공간자료 처리
library(tmap)  #공간자료 지도표현
library(tmap)  #공간자료 지도표현
install.packages("tmap")
library(tmap)  #공간자료 지도표현
library(tmap)  #공간자료 지도표현
install.packages("tmap")
library(tmap)  #공간자료 지도표현
# install.packages("remotes")
remotes::install_github("r-tmap/tmap")
# install.packages("remotes")
remotes::install_github("r-tmap/tmap")
nstall.packages("remotes")
install.packages("remotes")
remotes::install_github("r-tmap/tmap")
library(tmap)  #공간자료 지도표현
remotes::install_github("r-tmap/tmap")
1
remotes::install_github("r-tmap/tmap")
remotes::install_github("r-tmap/tmap")
library(tmap)  #공간자료 지도표현
getwd() # 현재 경로 확인
setwd("C:/Users/jungw/Dropbox/정우/lecture") # 경로 셋팅
# 파일 불러오기
gu_pp <-read.csv("./gu_pp.csv")
#속성표 확인 #총 25개 행(row), 2개 열(column)
str(gu_pp)
head(gu_pp)
# 요약 통계
summary(gu_pp$pp)
# 인구가 40만 이상인 구만 선택
gu_pp %>% filter(pp > 400000)
# 해당 데이터 행만 "large_gu"라는 데이터 프레임에 넣기
large_gu <- gu_pp %>% filter(pp > 400000)
library(dplyr) #데이터연산
library(sf) #공간자료 처리
library(ggmap) # 구글맵
library(ggplot2) #시각화
library(units) #단위 처리
# 인구가 40만 이상인 구만 선택
gu_pp %>% filter(pp > 400000)
# 해당 데이터 행만 "large_gu"라는 데이터 프레임에 넣기
large_gu <- gu_pp %>% filter(pp > 400000)
large_gu  #11개행만 들어감
seoul_gu_ <- st_read("C:/Users/user/Desktop/R_Study-main/lecture/week2/lecture/gu_seoul.shp", options ="ENCODING=EUC-KR")
seoul_gu <- st_read("./gu_seoul.shp", options ="ENCODING=EUC-KR")
#속성표 확인
#총 25개 행(row), 2개 열(column)
str(seoul_gu)
head(seoul_gu)
# 도형데이터로 면적 계산
st_area(seoul_gu)
# 도형데이터로 면적 계산 + 새로운 컬럼 "area" 생성
seoul_gu$area <- st_area(seoul_gu)
# 결과 확인
head(seoul_gu)
str(seoul_gu)
# 새로운 컬럼"area_km2" 생성: m2 -> km2 로 변환
seoul_gu$area_km2 <- as.numeric(seoul_gu$area/10^6)
#면적별 내림차순 정리
seoul_gu %>%
arrange(desc(area_km2))
# 그냥 두면 올림차순
seoul_gu %>%
arrange(area_km2)
str(seoul_gu)
#1. 기본 plot 시각화  -> 안이쁨
plot(seoul_gu["geometry"], col="grey", border= "blue", lwd=2, axes =TRUE)
#2. ggplot2 지도 시각화 -> 통계 시각화에 더 유용함
ggplot(data = seoul_gu) +
geom_sf(aes(fill = gu)) +
labs(title = "서울특별시 자치구",
fill = "자치구") +
theme_minimal() +
theme(legend.position = "right")  # 범례 위치 조정
#히스토그램 like this
ggplot(seoul_gu, aes(x = gu, y = area, fill= gu)) +
geom_bar(stat = "identity",color = "black") +
labs(title = "서울 자치구 면적",
x = "구",
y = "면적") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # x축 라벨 기울이기
tmap_mode("plot")
# 경계
tm_shape(seoul_gu) +
tm_polygons(col = "black", lwd  = 3)
# 면 채우기
tm_shape(seoul_gu) +
tm_polygons(fill = "red", fill_alpha = 0.5, col = "black", lwd  = 3)
tmap_mode("view")
# 단계구분도     # "jenks" 라는 단계구분 방법으로 6단계로 구분
tm_shape(seoul_gu) +
tm_polygons(fill = "area_km2", fill_alpha = 0.6, col = "black", lwd  = 3,
fill.scale = tm_scale_intervals("jenks", n = 6))
# 사전보기
?tm_polygons()
# 팔레트 보기
cols4all::c4a_palettes("seq")
# 팔레트 종류 변경한 단계구분도
tm_shape(seoul_gu) +
tm_polygons(fill = "area_km2", fill_alpha = 0.5, col = "black", lwd  = 3,
fill.scale = tm_scale_intervals("jenks", n = 6, values = "hcl.purples3"))
dongs <- st_read("C:/Users/user/Desktop/R_Study-main/lecture/week2/lecture/dongs.shp", options ="ENCODING=EUC-KR")
dongs <- st_read("./dongs.shp", options ="ENCODING=EUC-KR")
str(dongs)
head(dongs)
# 이름(문자열)로 특정 데이터 필터
daehak <- dongs %>% subset(ADM_NM == "대학동")
daehak2 <- dongs %>% subset(ADM_NM %in% c("대학동", "낙성대동"))
tm_shape(daehak) +
tm_polygons(fill="blue", col="black", lwd=3)
tm_shape(daehak2) +
tm_borders(fill="blue", col="black", lwd=3)
#구조확인
head(dongs)
#ADM_CD열 중 첫번째에서 두번째 글자가 ="11" 인 경우 추출
seoul_dong <- dongs %>% subset(substr(ADM_CD, 1, 2) == "11")
str(seoul_dong)
map1<- tm_shape(seoul_gu) +
tm_polygons(col ="darkblue", lwd = 2, fill_alpha=0)
map2 <-tm_shape(daehak2) +
tm_polygons(fill="blue", col="black", lwd=3)
text<- tm_shape(seoul_gu) +
tm_text(text = "gu", col = "black", size= 1)
map1 + map2 +  text +
tm_title("서울시 행정경계") +
tm_compass(type = "8star", position = c("left", "top")) +
tm_scalebar()
laus <- data.frame(
이름 = "LAUS",
상호명 = "건축도시공간연구실",
주소 = "37.4648267, 126.9571988",
유형 = "특별",
Latitude = 37.4648267,
Longitude = 126.9571988
)
laus
str(laus)
# sf 객체로 변환
laus_sf <- st_as_sf(laus, coords = c("Longitude", "Latitude"), crs = 4326)
str(laus_sf)
laus_dot <- tm_shape(laus_sf) +
tm_dots(
size = 1,
fill = "red"
) +
tm_text(
text = "이름",            # 텍스트로 표시할 변수
size = 1,              # 텍스트 크기
col = "black"            # 텍스트 그림자 추가
)
# 지도
laus_dot
# 겹쳐보기
map1+laus_dot
# data1 로드
food <- read.csv("C:./food.csv")
str(food)
head(food)
#data2 로드
price <- read.csv("C:./price.csv")
str(price)
head(price)
# left_join로 데이터 결합
food_price <- left_join(food, price, by = "이름")
head(food_price)
# food 데이터를 sf 객체로 변환 #tmap은 4326
food_price_sf <- st_as_sf(food_price, coords = c("Longitude", "Latitude"), crs = 4326)
# food_sf 데이터를 점으로 시각화
tm_shape(food_price_sf) +
tm_dots() +
tm_title("대상지")
map1 + text + laus_dot+
tm_shape(food_price_sf) +
tm_dots() +
tm_title("대상지")
head(food_price_sf)
# 유형별로 구분 # 색상을 price에 따라 변경해 봅시다!
map1 + laus_dot +
tm_shape(food_price_sf) +
tm_dots(
size = 1,                 # 점 크기 (고정 값)
fill = "유형",               # 색상 기준 변수
fill.scale = tm_scale(palette = "brewer.set2")
) +
tm_text(
text = "이름",            # 텍스트로 표시할 변수
size = 1,              # 텍스트 크기
col = "black"            # 텍스트 그림자 추가
) +
tm_title("음식점 유형별 위치") +
tm_scalebar(position = c("left", "bottom"))
# 거리 계산
st_geometry(food_price_sf)
st_geometry(laus_sf)
# crs 5179로 변경
food_price_sf <- st_transform(food_price_sf, crs = 5179)
laus_sf <- st_transform(laus_sf, crs = 5179)
#직선거리를 구해보자
dist_matrix <- st_distance(laus_sf, food_price_sf)
laus_sf
# 거리 값을 순서대로 food_sf$거리 컬럼에 입력
food_price_sf$거리 <- as.numeric(dist_matrix)
food_price_sf %>%
arrange(거리)
map1 + laus_dot +
tm_shape(food_price_sf) +
tm_dots(
size = 1,                 # 점 크기 (고정 값)
fill = "거리",               # 색상 기준 변수
fill.scale = tm_scale_intervals(values = "hcl.purples3")
) +
tm_text(
text = "이름",            # 텍스트로 표시할 변수
size = 1,              # 텍스트 크기
col = "black"            # 텍스트 색상
) +
tm_layout(legend.show = FALSE) +
tm_title("음식점 유형별 위치") +
tm_scalebar(position = c("left", "bottom"))
str(food_price_sf)
result <- food_price_sf %>%
arrange(거리)%>%
filter(price == min(price)) %>%
slice(1)
# result$상호명 값 포함한 문자열 생성
message <- paste("다음 회식 장소는", result$상호명, "입니다.")
print(message)
####6. 구글맵에 시각화 ####
register_google(" ")
####6. 구글맵에 시각화 ####
register_google("AIzaSyBelM8sb0Rwcwgp_llt7pQGOOnrhX0X8rg")
map <- get_map(
location = "south korea",
maptype = "roadmap",
source = "google",
color = "color"
)
ggmap::ggmap(map)
####6. 구글맵에 시각화 ####
register_google("AIzaSyBelM8sb0Rwcwgp_llt7pQGOOnrhX0X8rg")
map <- get_map(
location = "south korea",
maptype = "roadmap",
source = "google",
color = "color"
)
ggmap::ggmap(map)
# get_map()
seoul <- get_map(location = "seoul, south korea", zoom =12, maptype = "roadmap")
# ggmap()
ggmap::ggmap(seoul)
# ggmap을 활용해 지도 시각화
g <- ggmap(seoul) +
geom_point(data = food, aes(x = Longitude, y = Latitude), color = "blue", size = 3)
# ggmap()
print(g)
